一、AOP:面向切面编程==>指的是在程序运行期间，将某段代码动态地切入到指定方法的指定位置并运行的编程思想。
    1、JDK动态代理
    缺点：
        a.写法复杂；
        b.如果目标对象没有实现任何接口，无法使用动态代理创建出代理对象。
    2、Spring提供的AOP（底层实现原理就是动态代理）
        1）相关术语
            1.1）连接点(Joinpoint)：程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。 就是定义了哪一些地方是可以切入的，也就是所有允许你通知的地方。
            1.2）切点(Pointcut)：AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。
            1.3）通知(Advice)：通知是织入到目标类连接点上的一段程序代码，在Spring中，通知除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。
            1.4）目标对象(Target)：通知逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。
            1.5）引介(Introduction)：引介是一种特殊的通知，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。
            1.6）织入(Weaving)： 织入是将通知添加对目标类具体连接点上的过程。
            1.7）代理(Proxy)：一个类被AOP织入通知后，就产出了一个结果类，它是融合了原类和通知逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。
            1.8）切面(Aspect)： 切面由切点和通知组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。

    3、抽取可重用的切入点表达式
        步骤：
            1）随便声明一个没有实现的返回void的空方法
            2）给方法标注@Pointcut注解

    4、AOP应用场景
        1）加日志保存到数据库；
        2）权限验证；
        3）安全检查；
        4）事务控制。

    5.AOP的使用步骤
        1）基于注解方式
            a）将目标类和切面类加入到Spring容器中
            b）告诉Spring哪个切面类
            c）在切面类中使用五个通知注解来配置切面
            d）开启基于注解的AOP功能
        2）基于XML配置的AOP

二、Spring源码分析
    1、AOP（面向切面编程）
        1）底层就是动态代理，多个AOP就是多层动态代理。
    2、IOC（控制反转）
		1）IOC是一个容器
		2）容器启动的时候会创建所有单实例bean
		3）我们可以从容器中直接获取这个bean
		4）原理：（过于复杂）
		5）BeanFactory和ApplicationContext的区别
			a）BeanFactory：bean工厂接口，负责创建bean实例，是Spring最底层的接口；
			b）ApplicationContext：容器接口，更多地负责容器功能的实现，可以基于BeanFactory创建好的对象之上完成更强大的功能；
			c）	BeanFactory是最底层接口，ApplicationContext留给程序员使用的IOC容器接口，ApplicationContext是BeanFactory的子接口。

三、Spring事务详解
	1、属性
		1.1）isolation：事务的隔离级别
		1.2）propagation：事务的传播行为
		1.3）rollbackFor：设置哪些异常需要回滚事务（异常类类型）
		1.4）rollbackForClassName：设置哪些异常需要回滚事务（异常类全类名）
		1.5）noRollbackFor：设置哪些异常不需要回滚事务（异常类类型）
		1.6）noRollbackForClassName：设置哪些异常不需要回滚事务（异常类全类名）
		1.7）timeout：设置超时回滚时间（默认为false）：可以用来进行事务优化，加快查询速度
		1.8）readOnly：设置事务为只读事务（秒为单位）
	2、异常回滚细节
		2.1）运行时异常（非检查异常）：默认回滚
		2.2）编译时异常（检查异常）：默认不回滚
		2.3）即默认发生运行时异常都回滚，编译时异常回滚。
		2.4）noRollbackFor属性可以让那些运行时异常不回滚
		2.5）rollbackFor属性可以让那些编译时异常回滚
	3、事务的隔离级别：一个事务与其他事务的隔离程度。
		3.1）Read Uncommitted（读取未提交内容）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）
		3.2）Read Committed（读取提交内容）：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别，也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
		3.3）Repeatable Read（可重读）：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
		3.4）Serializable（可串行化）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
	4、四种隔离级别易造成的问题
		4.1）脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
		4.2）不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
		4.3）幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
		4.4）各个隔离级别可能造成的问题
			a）Read Uncommitted（读取未提交内容）：可能造成脏读、不可重复读和幻读问题。
			b）Read Committed（读取提交内容）：可能造成不可重复读和幻读。
			c）Repeatable Read（可重读）：可能造成幻读。
			d）Serializable（可串行化）：安全，不会有问题。
	5、Oracle只支持Read Committed（读取提交内容）和Serializable（可串行化），MySQL支持全部四种隔离级别。